<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>REST</h1>
					<h3>Representational State Transfer</h3>
					<p>
						<small>Created by <a href="https://github.com/danpersa">Dan Persa</a> / <a href="http://twitter.com/danpersa">@danpersa</a></small>
					</p>
				</section>

				<section data-markdown>
					<script type="text/template">
						## Table of Contents

						* SOAP vs REST
						* REST
						* Our REST Approach
						* API Design Principles
					</script>
				</section>

				<section>
					<section data-markdown>
						<script type="text/template">
							## SOAP - The Good

							* SOAP was great
							* has strictly defined interfaces
							* introduce breaking changes in an obvious way
							* produced type safety
							* WSDL provides some documentation for free
						</script>
					</section>

					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## SOAP - The Bad

							* Non breaking changes are hard
							* Introduce binary coupling between systems
							* Only uses XML
							* Sucks for some Tech Stacks
							* Verbose

							Notes:
							XML is harder to read than JSON
						</script>
					</section>
				</section>

				<section data-markdown data-separator-notes="^Notes:">
					<script type="text/template">
						Then Jesus said:

						> &ldquo;Come to me, all of you who are weary and carry heavy burdens, and I will give you **REST**.&rdquo;

						<p align="right">*Matthew 11:28*</p>

						Notes:
						REST is not a new thing… Roy Fielding wrote his dissertation in the year 2000… on the other hand, SOAP was designed as an object-access protocol in 1998 for Microsoft...

						so we could say that REST is 2 years younger SOAP… although some tech evangelists would still argue that there were people talking about REST more than 2000 years ago...
					</script>
				</section>

				<section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## REST

							* Non breaking changes are trivial
							* Allows upgrading independently
							* Stronger statement on backwards compatibility
								* When we were small, not so important
								* Now, very important
							* Opens the tech stack more

							Notes:
							What are the advantages of REST...
							Non breaking changes are trivial
							REST makes it possible to evolve APIs safely and without breaking them
						</script>
					</section>

					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## REST

							* More lightweight to create
							* Lots of modern tooling, lots of options
							* Accessible through the browser
							* No clients
						</script>
					</section>

					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## REST - The Bad

							* Less tooling for formal contracts
							* No clients means some code duplication across users

							Notes:
							Open source as a way to share code
						</script>
					</section>
				</section>

				<section data-markdown data-separator-notes="^Notes:" data-background="#ffffff">
					<script type="text/template">
						### Service Calling Made Easy

						![REST vs SOAP](images/rest-vs-soap-2.png)
						![REST vs SOAP](images/rest-vs-soap-1.png)

						Notes:
						Looking at this illustrations we can see that SOAP is much more polite than REST.

						Also that SOAP is much more verbose!
					</script>
				</section>

				<section data-markdown data-separator-notes="^Notes:" data-background="#ffffff">
					<script type="text/template">
						## XML API vs JSON API

						[http://tinyurl.com/xml-api-vs-json-api](http://tinyurl.com/xml-api-vs-json-api)

						![JSON API vs XML API](images/json-api-vs-xml-api.png)

						Notes:
						XML API vs JSON API on Google Trends
					</script>
				</section>

				<section data-markdown data-separator-notes="^Notes:">
					<script type="text/template">
						## REST - High Level

						* More autonomous teams
						* More things built like SaaS
						* Brings a high-level simplicity across all our APIs

						Notes:
						- Which is also the goal of Radical Agility
						- Important, as we are moving towards becoming a platform
						- An uniform interface is one of the constraints of REST
					</script>
				</section>

				<section data-markdown data-separator-notes="^Notes:">
					<script type="text/template">
						## The Promise of REST?

						Cacheable

						Stateless

						Scalable

						Fault Tolerant

						Recoverable

						Loosely coupled

						Secure

						Notes:
						REST is promising us a lot of cool stuff!!

						And we’ll talk about each of these points today.
					</script>
				</section>

				<section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							### The REST Acronym

							> &ldquo;The name **‘Representational State Transfer’** is intended to evoke
							> an image of how a well-designed Web application behaves: a network of web
							> pages (a virtual state-machine), where the user progresses through the
							> application by selecting links (state transitions), resulting in the next
							> page (representing the next state of the application) being transferred
							> to the user and rendered for their use.&rdquo;

							<p align="right">*Roy Fielding*</p>

							Notes:
							It’s worth pointing out that the user might be a human or a machine.
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							![REST Acronym Website](images/rest-acronym-website.svg)
							Notes:

							Here we have a diagram showing a well designed Web application.
							A network of web pages, where the user progresses through the application by selecting links.
							Resulting in the next page being transferred to the user and rendered for their use.

							But wait this is a regular web site :)

							This is not a surprise, as we all know that Roy Fielding's REST model is based on the Web.
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							### Representation of the Post1 resource
							```
							<html>
								<head>...</head>
								<body>
									<nav>
										<a href="/index">Home</a>
										<a href="/posts">Posts</a>
										...
									</nav>
									...
									<form action="/add-comment" method="POST">
										<input ...
									</form>
								</body>
							</html>
							```
							Notes:

							And talking about representations: Here is how we would represent the web page.
							What we can see here is some text. We all know that this text is a piece of HTML.
							The browser knows that also. The browser knows the format of the html and it's able
							to render it in a visual way. It knows that when it sees a form with input fields,
							it should let the user put some input in there. HTML is a media type and we'll talk about
							media type in more detail later.
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							![REST Acronym API](images/rest-acronym-api.svg)
							Notes:

							The Web was the model for REST so REST the generalization of the Web model. Here is how we
							would model a REST API with the same blog subject.
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							### Representation of the /blog/123/posts/post1 resource
							```
							Content-type: application/vnd.mycompany.post+json
							{
								id: "post1",
								title: "The Post",
								content: "...",
								author: "blog/123/authors/dan"
							}
							```
							Notes:

							Here is the representation of the post resource. It has a proprietary media type.
							The same as with the browser, a client should know the format of this media type, in order to be able to render it.
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							### Representation of the /blog/123/pages/index resource
							```
							Content-type: application/vnd.mycompany.page+json
							{
								id: "index",
								title: "The Index Page",
								teaser: "blog/123/teasers/1234"
								content: "...",
								 [
									{
										display_name: "Contact",
										id: "blog/123/pages/contact"
									}
									...
								]
							}
							```
							Notes:
						</script>
					</section>
				</section>

				<section data-markdown data-separator-notes="^Notes:">
					<script type="text/template">
						### What is REST?
						> &ldquo;REST provides a set of architectural constraints that, when **applied
						> as a whole**, emphasizes scalability of component interactions, generality of
						> interfaces, independent deployment of components, and intermediary
						> components to reduce interaction latency, enforce security, and encapsulate
						> legacy systems.&rdquo;

						<p align="right">*Roy Fielding*</p>

						Notes:
						REST and architecture style based on constraints

						In order to gain everything that REST promises, we should apply these constraints as a whole.
					</script>
				</section>

				<section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## The REST Constraints
						</script>
					</section>

					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## C1. Client Server

							A client is a triggering process

							A server is a reactive process

							Clients make requests that trigger reactions from servers

							A client initiates activity at times of its choosing

							A server waits for requests to be made and then reacts to them
							<p align="right"><small><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm#sec_3_4_1">Reference</a></small></p>

							Notes:
							We said that REST is based on constraints! Let’s see the first one! We can’t have REST if we don’t have a server and a client.

							A server component, offering a set of services, listens for requests upon those services. A client component, desiring that a service
							be performed, sends a request to the server via a connector. The server either rejects or performs the request and sends a response back to the client

							A client is a triggering process; a server is a reactive process. Clients make requests that trigger reactions from servers

							On the other hand, a server waits for requests to be made and then reacts to them
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## C1. Client Server
							![Client Server Constraint](images/rest-client-server-constraint.svg)
							Notes:
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## C1. Client Server

							Separation of concerns

							Separate the UI from Data Storage

							### Advantages

							* Improve the portability of the UI
							* Improve scalability by simplifying the server components
							* Allows the components to evolve independently

							<p align="right"><small><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_2">Reference</a></small></p>

							Notes:
							Separation of concerns is the principle behind the client-server constraints.

							By separating the user interface concerns from the data storage concerns, we improve the portability of the user interface
							across multiple platforms and improve scalability by simplifying the server components.

							The most significant to the Web is that the separation allows the components to evolve independently!
						</script>
					</section>

					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## C2. Stateless

							Communication must be stateless in nature

							Each request from the client to server must contain all of the info necessary to understand the request

							Requests cannot take advantage  of any stored context on the server

							Session state is kept entirely on the client

							<p align="right"><small><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_3">Reference</a></small></p>

							Notes:
							We next add a new constraint to the client-server interaction:

							Communication must be stateless in nature, such that each request from client to server must contain all of the
							information necessary to understand the request, and cannot take advantage of any stored context on the server.

							Session state is therefore kept entirely on the client.
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## C2. Stateless
							![Stateless Constraint](images/rest-stateless-constraint.svg)
							Notes:
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## C2. Stateless

							Visibility

							Reliability

							Scalability

							* Tradeoffs
								* Network performance
								* Reduce the server’s control over consistent application behaviour
								* Multiple client versions

							<p align="right"><small><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_3">Reference</a></small></p>

							Notes:
							This constraint induces the properties of visibility, reliability, and scalability.

							Visibility is improved because a monitoring system does not have to look beyond a single request in order to
							determine the full nature of the request.

							Reliability is improved because it eases the task of recovering from partial failures.

							Scalability is improved because not having to store state between requests allows the server component to quickly
							free resources, and further simplifies implementation because the server doesn't have to manage resource usage across requests.

							Like most architectural choices, the stateless constraint reflects a design trade-off. The disadvantage is that it may
							decrease network performance by increasing the repetitive data sent in a series of
							requests, since that data cannot be left on the server in a shared context.

							In addition, placing the application state on the client-side reduces the server's control over consistent application
							behavior, since the application becomes dependent on the correct implementation of semantics across multiple client versions.
						</script>
					</section>

					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## C3. Cache

							Label data as cacheable or non-cacheable

							Potential of completely eliminate some interactions

							Improves efficiency, scalability and user-perceived performance

							Degrades reliability

							<p align="right"><small><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_4">Reference</a></small></p>

							Notes:
							In order to improve network efficiency, REST adds the cache constraints. Cache constraints require that the data within a response to a request be implicitly or explicitly labeled as cacheable or non-cacheable. If a response is cacheable, then a client cache is given the right to reuse that response data for later, equivalent requests.

							The advantage of adding cache constraints is that they have the potential to partially or completely eliminate some interactions, improving efficiency, scalability, and user-perceived performance by reducing the average latency of a series of interactions.

							The tradeoff, however, is that a cache can decrease reliability if stale data within the cache differs significantly from the data that would have been obtained if the request would have been sent directly to the server.
						</script>
					</section>

					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## C3. Cache
							![Cache Constraint](images/rest-caching-constraint.svg)
							Notes:
						</script>
					</section>

					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## C4. Uniform Interface

							Simplified architecture

							Improves visibility

							Decouples implementation

							Independent evolvability

							Degraded efficiency
							<p align="right"><small><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_5">Reference</a></small></p>

							Notes:
							The central feature that distinguishes the REST architectural style from other network-based styles is its emphasis on an uniform
							interface between components.

							By applying the software engineering principle of generality to the component interface, the overall system architecture is simplified and the
							visibility of interactions is improved.

							Implementations are decoupled from the services they provide, which encourages independent evolvability.

							The trade-off, though, is that a uniform interface degrades efficiency, since information is transferred in a standardized form rather than
							one which is specific to an application's needs.

							The REST interface is designed to be efficient for large-grain hypermedia data transfer, optimizing for the common case of the Web, but resulting
							in an interface that is not optimal for other forms of architectural interaction.
						</script>
					</section>

					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## C4. Uniform Interface

							![Uniform Interface Constraint](images/rest-uniform-interface-constraint.svg)
							Notes:
						</script>
					</section>

					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## C4. Uniform Interface

							REST is defined by four interface constraints:

							* Identification of resources
							* Manipulation of resources through representations
							* Self-descriptive messages
							* Hypermedia as the engine of application state

							<p align="right"><small><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_5">Reference</a></small></p>

							Notes:

							In order to obtain an uniform interface, multiple architectural constraints are needed to guide the behavior of components.

							REST is defined by four interface constraints: identification of resources; manipulation of resources through representations;
							self-descriptive messages; and, hypermedia as the engine of application state
						</script>
					</section>

					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## C5. Layered System

							Architecture composed by hierarchical layers

							Each component cannot “see” beyond the immediate layer

							Layers can encapsulate legacy service

							Protect new services from legacy clients

							Intermediaries can be used to improve system scalability by enabling load balancing

							Simplifying components

							Allow enforcing security policies

							<p align="right"><small><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_6">Reference</a></small></p>

							Notes:
							The layered system style allows an architecture to be composed of hierarchical layers by constraining component behavior such
							that each component cannot "see" beyond the immediate layer with which they are interacting.

							By restricting knowledge of the system to a single layer, we place a bound on the overall system complexity and promote substrate
							independence. Layers can be used to encapsulate legacy services and to protect new services from legacy clients, simplifying components
							by moving infrequently used functionality to a shared intermediary. Intermediaries can also be used to improve system scalability by
							enabling load balancing of services across multiple networks and processors.

							Such layers also allow security policies to be enforced on data crossing the organizational boundary, as is required by firewalls.
						</script>
					</section>

					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## C5. Layered System
							![Layered System Constraint](images/rest-layered-system-constraint.svg)
							Notes:
						</script>
					</section>

					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## C5. Layered System

							Add overhead and latency to the processing of data

							Reduce user-perceived performance

							Caching is really important

							<p align="right"><small><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_6">Reference</a></small></p>

							Notes:
							The primary disadvantage of layered systems is that they add overhead and latency to the processing of data, reducing user-perceived performance.

							For a network-based system that supports cache constraints, this can be offset by the benefits of shared caching at intermediaries.

							Placing shared caches at the boundaries of the domain can result in significant performance benefits.
						</script>
					</section>
				</section>

				<section data-markdown data-separator-notes="^Notes:">
					<script type="text/template">
						## REST Key Concepts

						Notes:
					</script>
				</section>

				<section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Resource

							Any info that can be named can be a resource

							Any concept that might be the target of an author’s hypertext reference

							A resource is a conceptual mapping to a set of entities, not the entity that corresponds to the mapping

							<p align="right"><small><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2_1_1">Reference</a></small></p>
							Notes:

							The key abstraction of information in REST is a resource. Any information that can be named can be a resource: a document or image,
							a temporal service (e.g. "today's weather in Berlin"), a collection of other resources, a non-virtual object (e.g. a person), and so on.

							In other words, any concept that might be the target of an author's hypertext reference must fit within the definition of a resource.

							A resource is a conceptual mapping to a set of entities, not the entity that corresponds to the mapping at any particular point in time.
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							```
							     +---------+  +------------------------------+  +-------------+
							     |         |  |                              |  |             |
							     | /books  |  | /authors/{id}/favorite-books |  | /books/{id} |
							     |         |  |                              |  |             |
							     +----+----+  +---------------+--------------+  +------+------+
							          |                       |                        |
							          |                       |                        |
							      All Books             Author's Favorite        Book with id
							      Resource              Books Resource             Resource
							          |                       |                        |
							          |                       |                        |
							          |                       v                        |
							          |                +------------+                  |
							          |                |            |                  |
							          +--------------> |  Books DB  | <----------------+
							                           |            |
							                           +------------+
							```

							Notes:
							Let s take an example. In this diagram we have a database and three resources.
						</script>
					</section>
				</section>

				<section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Resource Identifiers

							REST uses a resource identifier to identify the particular resource involved in an interaction

							Generic interface for accessing and manipulating the value set of a resource

							REST relies on the author choosing a resource identifier that best fits the concept being identified

							<p align="right"><small><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2_1_1">Reference</a></small></p>
							Notes:

							REST uses a resource identifier to identify the particular resource involved in an interaction between components.

							REST connectors provide a generic interface for accessing and manipulating the value set of a resource, regardless of
							the type of software that is handling the request.

							REST doesn't dictate URI choice. Leaves it to the application author
						</script>
					</section>

					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Resource Identifiers

							`/index.php/action=getpost&id=3`

							`/default/post/2/4/1/size`


							<p class="fragment roll-in">~~Cachable?~~</p>
							<p class="fragment roll-in">~~Scalable?~~</p>
							<p class="fragment roll-in">~~Readable?~~</p>
						</script>
					</section>

					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Resource Identifiers

							`/posts`

							<small>all the posts resource</small>

							`/posts/5/photos/3/comments/1`

							<small>the first comment of the third photo for the fifth post resource</small>

							`/posts/5/photos/3/comments`

							<small>all the comments of the thirds photo for the fifth post resource</small>

							**Cachable! Scalable! Readable!**
						</script>
					</section>

					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Resource Identifiers - Filtering

							✘ `/posts/order/size/limit/4`

							✘ `/posts/limit/5/order/size`

							✔︎ `/posts?order=size&limit=4`

							✔︎ `/posts?limit=5&order=size`

							Notes:
							It doesn't make sense to return all of the posts, using the posts resource. That's why we need to filter it.
							The rule is that we should filter through a Query String, not the URI
						</script>
					</section>
				</section>

				<section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Representations

							A representation captures the current or intended state of a resource

							A representation is a sequence of bytes, plus representation metadata to describe the bytes

							A particular resource may have multiple representations

							<p align="right"><small><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2_1_2">Reference</a></small></p>
							Notes:
							REST components perform actions on a resource by using a representation to capture the current or intended state of that
							resource and transferring that representation between components. A representation is a sequence of bytes,
							plus representation metadata to describe those bytes.

							Other commonly used but less precise names for a representation include: document, file, and HTTP message entity, instance, or variant.
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Representations
							```
							HTTP/1.1 200 OK
							Content-length: 1234
							Content-type: application/vnd.mycompany.customer+json

							{
								"name": "Forrest Gump",
								"email": "forrest@gump.com"
								"phone": "(123) 456-789"
							}
							```

							```
							HTTP/1.1 200 OK
							Content-length: 1234
							Content-type: text/vcard

							BEGIN:VCARD
							VERSION:4.0
							N:Gump;Forrest;;;
							FN:Forrest Gump
							ORG:Bubba Gump Shrimp Co.
							TEL;TYPE=home,voice;VALUE=uri:tel:+1-404-555-1212
							EMAIL:forrestgump@example.com
							REV:20080424T195243Z
							END:VCARD
							```
							Notes:

							Here we have two representations of the same resource.

						</script>
					</section>
				</section>

				<section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Content Negotiation

							If the value set of a resource at a given time consists of multiple representations, content negotiation may be used to select the best representation for inclusion in a given message.

							<p align="right"><small><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2_1_2">Reference</a></small></p>

							Notes:

							If the value set of a resource at a given time consists of multiple representations, content negotiation may be used to select the best representation for inclusion in a given message.
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Content Negotiation
							```
							GET /customers/1234 HTTP/1.1
							Host: example.com
							Accept: application/vnd.mycompany.customer+json
							```

							```
							GET /customers/1234 HTTP/1.1
							Host: example.com
							Accept: text/vcard
							```

							```
							GET /customers/1234 HTTP/1.1
							Host: example.com
							Accept: application/vnd.mycompany.customer+json;q=0.5, text/vcard
							```

							Notes:
							How do we do this? The client specifies an Accept header

							Quality factors allow the user or user agent to indicate the relative degree of preference for that media-range, using the qvalue scale from 0 to 1
						</script>
					</section>
				</section>

				<section data-markdown data-separator-notes="^Notes:">
					<script type="text/template">
						## Media Types

						The data format of a representation

						A representation is processed according to the control data of the message and the nature of the media type

						Some media types are intended for automated processing, some to be rendered for viewing by an user, few, capable of both

						<p align="right"><small><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2_1_2">Reference</a></small></p>
						Notes:
						The data format of a representation is known as a media type.

						A representation can be included in a message and processed by the recipient according to the control data of
						the message and the nature of the media type.

						Some media types are intended for automated processing, some are intended to be rendered for viewing by a user,
						and a few are capable of both. Composite media types can be used to enclose multiple representations in a single message.

						The design of a media type can directly impact the user-perceived performance of a distributed hypermedia system.
						Any data that must be received before the recipient can begin rendering the representation adds to the latency of an interaction.

						A data format that places the most important rendering information up front, such that the initial information can be
						incrementally rendered while the rest of the information is being received, results in much better user-perceived performance
						than a data format that must be entirely received before rendering can begin.

						For example, a Web browser that can incrementally render a large HTML document while it is being received provides significantly
						better user-perceived performance than one that waits until the entire document is completely received prior to rendering,
						even though the network performance is the same.
					</script>
				</section>


				<section>
					<section data-markdown data-separator-notes="^Notes:" data-background="#ffffff">
						<script type="text/template">
							## Richardson Maturity Model

							![Richardson Maturity Model](images/richardson.png)

							<p align="right"><small><a href="http://martinfowler.com/articles/richardsonMaturityModel.html">More Info</a></small></p>
							Notes:
							How do we measure how RESTful our API is?
						</script>
					</section>

					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Level 0: The Swamp of Pox

							One URI, one HTTP method

							XML-RPC / SOAP / POX

							Giant “black box”
						</script>
					</section>

					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Level 1: Resources

							Each resource has an unique URI

							Single HTTP verb (usually POST or GET)

							Verbs have no meaning, used to tunnel over HTTP
						</script>
					</section>

					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Level 2: HTTP Verbs

							Many URIs, using multiple verbs

							Correct use of response codes

							Exposes state, not behavior

							CRUD Services
						</script>
					</section>

					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Level 3: Hypermedia Controls

							Resources are self-describing

							Hypermedia As The Engine Of Application State (HATEOAS)

							Exposes state and behavior
						</script>
					</section>
				</section>

				<section data-markdown data-separator-notes="^Notes:">
					<script type="text/template">
						> &ldquo;Our nature consist in motion; complete **REST** is death.&rdquo;

						<p align="right">*Blaise Pascal*</p>

						Notes:
						Doing complete REST is hard. Some guys are pessimistic about this… like Blaise Pascal...
					</script>
				</section>

				<section data-markdown data-separator-notes="^Notes:">
					<script type="text/template">
						## Can we name our API RESTful?

						> &ldquo;What needs to be done to make the REST architectural style clear
						> on the notion that **hypertext is a constraint**? In other words, if the
						> engine of application state (and hence the API) is **NOT being driven by
						> hypertext**, then it cannot be RESTful and **cannot be a REST API**.
						> Period. Is there some broken manual somewhere that needs to be fixed?&rdquo;

						<p align="right">*Roy Fielding*</p>

						Notes:
						But if we are not doing complete REST, can we say that our API is RESTful?

						Roy Fielding was explicit about it!

						This slide focuses on Level 3… the which is the hardest to implement...
					</script>
				</section>

				<section data-markdown data-separator-notes="^Notes:">
					<script type="text/template">
						> &ldquo;Believe in yourself, and the REST will fall into place. Have
						> faith in your own abilities, work hard, and there is nothing you cannot
						> accomplish.&rdquo;

						<p align="right">*Brad Henry*</p>

						Notes:
						So what can we do?
					</script>
				</section>

				<section data-markdown data-separator-notes="^Notes:" data-background="#E6C8D9" data-background-transition="zoom">
					<script type="text/template">
						## Our REST Approach

						We prefer REST-based APIs with JSON payloads

						We prefer systems to be truly RESTful

						**Our goal:**

						To build interoperating distributed systems that can be evolved in parallel
						by different teams while continuing to work.

						Notes:

						We prefer REST-based APIs with JSON payloads due to their weak type system
						instead of SOAP with it’s strong type system.

						We prefer systems to be truly RESTful, not just JSON RPC, since the goals
						of REST are the same as our goals: to build interoperating distributed
						systems that can be evolved in parallel by different teams while
						continuing to work.
					</script>
				</section>

				<section data-markdown data-separator-notes="^Notes:" data-background="#FFCBAA" data-background-transition="zoom">
					<script type="text/template">
						## API Design Principles

						API-first

						Peer review by the API Guild

						See the [swagger-editor](http://editor.swagger.io/)

						Central place for documentation

						Notes:

						We prefer peer-reviewed, API-first.  This means that APIs are developed outside
						code, for example using Swagger (see https://github.com/sarnowski/swagger1st/
						or https://github.com/swagger-api/swagger-editor or https://github.com/swagger-api/swagger-codegen).

						Our APIs need to last for a long time. APIs can only be evolved in certain ways,
						bigger changes are hard and expensive, and our APIs are the most pure expression
						of what our systems do. So we prefer APIs to be designed outside of code at first,
						and ongoing documentation to be generated from the code itself. API design is hard
						work and takes time, and benefits from peer review. We want our APIs to all be
						similar in tone, and we need to establish and agree to standards for how to do this.

						We will host API documentation for all our APIs in a central, searchable place.

						Documentation should always provide examples.
					</script>
				</section>

				<section data-markdown data-separator-notes="^Notes:">
					<script type="text/template">
						## Robustness Principle - aka Postel’s Law

						> &ldquo;Be liberal in what you accept, be conservative in what you send&rdquo;

						<p align="right">[*RFC 1122*](http://www.rfc-editor.org/rfc/rfc1122.txt)</p>

						* Ignore unknown fields in JSON payload
						* Evolve by adding optional fields
						* No need for versioning your API
						* Having the version within the url is not considered RESTful


						Notes:

						Our APIs should obey Postel's Law (aka the Robustness Principle):
						Be conservative in what you send, be liberal in what you accept.
					</script>
				</section>

				<section data-markdown data-separator-notes="^Notes:">
					<script type="text/template">
						## API Guild

						Reviews the API

						Set of best practices

						Trainings and certifications on API Design

						Notes:

						The review will be done by the members of the API Guild. API Guild had its kick off
						meeting in the middle of March. The members of the Guild are Zalando people passionate
						about REST.

						We started as a small group of people, and in the future we will grow a lot.
						Everybody should be able to join the API Guild after some training.

						API Guild will provide guidance and support to the ones who want to create APIs.
						We will also review the APIs. And create a document with best practices to guide
						the developers when creating APIs. Some of these best practices will be optional,
						some of them mandatory.
					</script>
				</section>

				<section data-markdown data-separator-notes="^Notes:">
					<script type="text/template">
						## SaaS

						Offer SaaS to 3rd parties

						Consider any other system a 3rd party with regards to API structure, resilience and service level

						AWS pushes us that way

						Notes:
						Build your services in a way that it would be possible to offer them as a SaaS solution to 3rd parties.

						In fact consider any other system a 3rd party with regards to API structure, resilience and service level.

						This is not so hard compared to a few years ago. AWS pushes us this way, the internet model scales,
						and we are working on a security model which allows our services to be on the open Internet.
					</script>
				</section>

				<section data-markdown data-separator-notes="^Notes:">
					<script type="text/template">
						## Security

						Always use SSL

						Make sure the caller of your service is authenticated and authorized

						Notes:
						Always use SSL and make sure the caller of your service is authenticated and authorized.
					</script>
				</section>

				<section data-markdown data-separator-notes="^Notes:" data-background-transition="convex">
					<script type="text/template">
						## Implementation Guidelines

						### Idempotent
						Make service endpoints idempotent

						### Immutability
						Prefer immutability

						Notes:

						Idempotent

						Whenever possible and reasonable, make service endpoints idempotent.

						This means that an operation will produce the same results if executed once or multiple times.

						In a distributed system, things fail in lots of ways, and when a client sees a failure, the core call may
						have failed -- the failure could have occurred in the network late in the process.

						So it is helpful if a client can try again, even for stateful operations. This has some deep impacts; for example
						it may mean that the client should generate a unique id when putting new data into a service endpoint,
						rather than relying on the service to do it.

						This might imply that the calling client needs to, for example, be able to generate a UUID.

						Immutable

						Prefer immutability whenever possible. This is a key concept from Effective Java, and languages like
						Scala and Clojure have stronger support for this than Java.
						Immutability tends to result in fewer bugs and make it easier to prove that a program is correct.
						Immutable things are automatically thread safe, with no synchronization required.
					</script>
				</section>

				<section data-markdown data-separator-notes="^Notes:" data-background-transition="concave">
					<script type="text/template">
						> &ldquo;If you find yourself in need of a batch operation, then most likely you just haven’t defined enough resources.&rdquo;

						<p align="right">*Roy Fielding*</p>
					</script>
				</section>

				<section data-markdown data-separator-notes="^Notes:" data-background="#AEDE94" data-background-transition="fade">
					<script type="text/template">
						## References

						* [Architectural Styles and the Design of Network-based Software Architectures](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)
						* [InfoQ eMag: Web APIs: From Start to Finish](http://www.infoq.com/minibooks/emag-web-api)
						* [REST APIs must be hypertext-driven](http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)
						* [Haters gonna HATEOAS](http://timelessrepo.com/haters-gonna-hateoas)
						* [Richardson Maturity Model](http://martinfowler.com/articles/richardsonMaturityModel.html)
						* [Versioning REST Web Services](http://barelyenough.org/blog/2008/05/versioning-rest-web-services/)
						* [The HTTP OPTIONS method and potential for self-describing RESTful APIs](http://zacstewart.com/2012/04/14/http-options-method.html)
						* [A Little Rest and Relaxation](http://www.slideshare.net/royfielding/a-little-rest-and-relaxation)
						* [REST and HATEOAS](http://www.slideshare.net/XEmacs/representational-state-transfer-rest-and-hateoas)

						Notes:
						In reality, the effort required to design something is inversely proportional to the simplicity of the result.

						REST is software design on the scale of decades: every detail is intended to promote software longevity and
						independent evolution. Many of the constraints are directly opposed to short-term efficiency.
						Unfortunately, people are fairly good at short-term design, and usually awful at long-term design.
					</script>
				</section>

				<section data-background="images/thats-all-folks.jpg" data-background-transition="zoom"></section>

				<!-- <section id="themes">
					<h2>Themes</h2>
					<p>
						reveal.js comes with a few themes built in: <br>
						<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/black.css'); return false;">Black (default)</a> -
						<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/white.css'); return false;">White</a> -
						<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/league.css'); return false;">League</a> -
						<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/sky.css'); return false;">Sky</a> -
						<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/beige.css'); return false;">Beige</a> -
						<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/simple.css'); return false;">Simple</a> <br>
						<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/serif.css'); return false;">Serif</a> -
						<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/night.css'); return false;">Night</a> -
						<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/moon.css'); return false;">Moon</a> -
						<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/solarized.css'); return false;">Solarized</a>
					</p>
				</section> -->
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
